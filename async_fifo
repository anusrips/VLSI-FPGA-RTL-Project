
module async_fifo #(
    parameter DATA_WIDTH = 8,
    parameter FIFO_DEPTH = 16,
    parameter ADDR_WIDTH = 4          // log2(FIFO_DEPTH)
)(
    input  wire                  wclk,
    input  wire                  rclk,
    input  wire                  rst_n,

    // Write side
    input  wire                  write_en,
    input  wire [DATA_WIDTH-1:0] wdata,
    output wire                  full,

    // Read side
    input  wire                  read_en,
    output reg  [DATA_WIDTH-1:0] rdata,
    output wire                  empty
);

    // FIFO Memory
    reg [DATA_WIDTH-1:0] mem [0:FIFO_DEPTH-1];

    // Pointer registers (binary + gray)
    reg [ADDR_WIDTH:0] wptr_bin, rptr_bin;
    reg [ADDR_WIDTH:0] wptr_gray, rptr_gray;

    // Next-value logic
    wire [ADDR_WIDTH:0] wptr_bin_next, rptr_bin_next;
    wire [ADDR_WIDTH:0] wptr_gray_next, rptr_gray_next;

    assign wptr_bin_next  = wptr_bin + ((write_en & !full)  ? 1 : 0);
    assign rptr_bin_next  = rptr_bin + ((read_en  & !empty) ? 1 : 0);

    assign wptr_gray_next = (wptr_bin_next >> 1) ^ wptr_bin_next;
    assign rptr_gray_next = (rptr_bin_next >> 1) ^ rptr_bin_next;

    // Pointer Synchronizers
    reg [ADDR_WIDTH:0] rptr_gray_wclk_ff1, rptr_gray_wclk_ff2;
    reg [ADDR_WIDTH:0] wptr_gray_rclk_ff1, wptr_gray_rclk_ff2;

    // Sync read pointer into write clock domain
    always @(posedge wclk or negedge rst_n) begin
        if (!rst_n) begin
            rptr_gray_wclk_ff1 <= 0;
            rptr_gray_wclk_ff2 <= 0;
        end else begin
            rptr_gray_wclk_ff1 <= rptr_gray;
            rptr_gray_wclk_ff2 <= rptr_gray_wclk_ff1;
        end
    end

    // Sync write pointer into read clock domain
    always @(posedge rclk or negedge rst_n) begin
        if (!rst_n) begin
            wptr_gray_rclk_ff1 <= 0;
            wptr_gray_rclk_ff2 <= 0;
        end else begin
            wptr_gray_rclk_ff1 <= wptr_gray;
            wptr_gray_rclk_ff2 <= wptr_gray_rclk_ff1;
        end
    end

  
    // Write logic
   
    always @(posedge wclk or negedge rst_n) begin
        if (!rst_n) begin
            wptr_bin  <= 0;
            wptr_gray <= 0;
        end else begin
            wptr_bin  <= wptr_bin_next;
            wptr_gray <= wptr_gray_next;

            if (write_en && !full)
                mem[wptr_bin[ADDR_WIDTH-1:0]] <= wdata;
        end
    end

    // Read logic
    always @(posedge rclk or negedge rst_n) begin
        if (!rst_n) begin
            rptr_bin  <= 0;
            rptr_gray <= 0;
            rdata     <= 0;
        end else begin
            rptr_bin  <= rptr_bin_next;
            rptr_gray <= rptr_gray_next;

            if (read_en && !empty)
                rdata <= mem[rptr_bin[ADDR_WIDTH-1:0]];
        end
    end

    // Full/Empty logic (simple & standard)
    assign full  = (wptr_gray_next == {~rptr_gray_wclk_ff2[ADDR_WIDTH:ADDR_WIDTH-1],
                                       rptr_gray_wclk_ff2[ADDR_WIDTH-2:0]});

    assign empty = (wptr_gray_rclk_ff2 == rptr_gray);

endmodule

